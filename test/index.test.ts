import Fastify, { FastifyInstance } from 'fastify';
import { Client } from 'pg';
import Database, { FastifyPgOptions } from '../src';

const appOptions = {
  logger: true,
};

const connectionOptions = {
  host: 'localhost',
  port: 5432,
  user: 'postgres',
  password: 'postgres',
};

const database = 'fastify-pg-test';

async function getConfiguredApp(opts: Partial<FastifyPgOptions> = {}) {
  const app = Fastify(appOptions);
  app.register(Database, { ...connectionOptions, database, ...opts });
  await app.ready();
  return app;
}

let app: FastifyInstance;

beforeEach(async () => {
  app = await getConfiguredApp();
});

afterEach(async () => {
  await app.close();
  const client = new Client(connectionOptions);
  await client.connect();
  await client.query(`DROP DATABASE "${database}"`);
  await client.end();
});

describe('fastify-pg', () => {
  test('basic query', async () => {
    const res = await app.database.query('SELECT 1 + 1 AS result');
    expect(res.rowCount).toEqual(1);
    expect(res.rows).toEqual([{ result: 2 }]);
  });

  test('migrations', async () => {
    const app2 = await getConfiguredApp({ migrationsDirectory: 'test' });
    const res = await app2.database.query('SELECT * FROM test_table');
    expect(res.rowCount).toEqual(3);
    await app2.close();
  });
});

describe('transaction', () => {
  test('transaction', async () => {
    const transaction = await app.database.transaction();
    await transaction.query(
      `CREATE TABLE bananas(
        id INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL
      )`,
    );
    await transaction.query(`INSERT INTO bananas (name) VALUES ('hello'), ('there'), ('banana')`);
    await transaction.commit();
    const res = await app.database.query('SELECT * FROM bananas');
    expect(res.rowCount).toEqual(3);
  });

  test('transaction with rollback', async () => {
    const transaction = await app.database.transaction();
    await transaction.query(
      `CREATE TABLE bananas(
        id INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL
      )`,
    );
    await transaction.query(`INSERT INTO bananas (name) VALUES ('hello'), ('there'), ('banana')`);
    await transaction.rollback();
    const res = await app.database.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE  table_schema = 'public'
        AND    table_name   = 'bananas'
      ) AS "tableExists"
    `);
    const [{ tableExists }] = res.rows;
    expect(tableExists).toEqual(false);
  });

  test('transaction with callback', async () => {
    await app.database.transaction(async query => {
      await query(`CREATE TABLE bananas(
        id INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL
      )`);
      await query(`INSERT INTO bananas (name) VALUES ('hello'), ('there'), ('banana')`);
    });
    const {
      rows: [{ tableExists }],
    } = await app.database.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE  table_schema = 'public'
        AND    table_name   = 'bananas'
      ) AS "tableExists"
    `);
    expect(tableExists).toEqual(true);
  });

  test('transaction with callback and throwing error', async () => {
    await app.database
      .transaction(async query => {
        await query(`CREATE TABLE bananas(
        id INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,
        name TEXT NOT NULL
      )`);
        await query(`INSERT INTO bananas (name) VALUES ('hello'), ('there'), ('banana')`);
        throw new Error('blin');
      })
      .catch(() => void 0);
    const {
      rows: [{ tableExists }],
    } = await app.database.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE  table_schema = 'public'
        AND    table_name   = 'bananas'
      ) AS "tableExists"
    `);
    expect(tableExists).toEqual(false);
  });
});
